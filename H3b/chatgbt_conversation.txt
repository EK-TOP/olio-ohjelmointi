
Sin√§ sanoit:
L√§hetetty kuva
T√§ss√§ teht√§v√§ss√§ harjoitellaan periytymist√§ ja metodien ylikirjoittamista C++-ohjelmoinnissa. Tavoitteena on ymm√§rt√§√§, miten periv√§ luokka voi ylikirjoittaa kantaluokan metodin, ja n√§hd√§ polymorfismi k√§yt√§nn√∂ss√§ C++:ssa.

OHJE: https://peatutor.com/cplus/index.php#overriding

Noudata k√§yt√§nt√∂√§, ett√§ kullekin luokalle luodaan oma header-tiedosto ja oma cpp-tiedosto, joilla on sama nimi kuin luokalla. T√§m√§ hoituu automaattisesti, kun luot luokat Qt-Creatorin toiminnolla "Add New -> C++ Class". Tutustu aluksi UML-kaavion symbooleihin kts. https://peatutor.com/cplus/index.php#uml

Harjoitus3b (perint√§/ylikirjoittaminen)

Luo C++-projekti nimelt√§√§n h3b

    Lis√§√§ projektiin kantaluokka nimelt√§ Animal, joka sis√§lt√§√§ virtuaalisen metodin callOut. T√§m√§ metodi tulostaa tekstin "El√§in √§√§ntelee."
    Luo kantaluokasta periv√§ luokka nimelt√§ Dog, joka ylikirjoittaa metodin callOut. Ylikirjoitetun metodin tulisi tulostaa teksti "Koira haukkuu!"
    Kirjoita main-funktio, jossa luodaan Animal-luokan olio ja Dog-luokan olio.
    Kutsu molemmissa tapauksissa callOut-metodia ja varmista, ett√§ oikea viesti tulostuu.
    Varmista, ett√§ luomasi oliot tuhoutuvat.

Lis√§tietoa
C++: Polymorfismi luokkien Animal ja Dog v√§lill√§

Kun sinulla on C++-ohjelmassa, perint√§suhde luokkien Animal ja Dog v√§lill√§, voit luoda ja k√§sitell√§ olion joko kantaluokan (Animal) tai periv√§nluokan (Dog) tyypin kautta. Molemmilla tavoilla on etunsa. Tarkastellaan ensin molempia tapoja:

Huom! Modernissa C++:ssa k√§ytet√§√§n √§lykk√§it√§ osoittimia (smart pointers) kuten unique_ptr tai shared_ptr raakaosoittimien sijaan. N√§in muisti vapautuu automaattisesti eik√§ delete-komentoa tarvita.

    unique_ptr<Animal> dog = make_unique<Dog>(); (Polymorfismi)
    unique_ptr<Dog> dog = make_unique<Dog>(); (Periv√§nluokan k√§ytt√∂ suoraan)

1. Polymorfinen olio

Plolymorfinen olio voidaan luoda lauseella: unique_ptr<Animal> dog = make_unique<Dog>();, jolloin k√§ytet√§√§n kantaluokan tyyppi√§, mutta luodaan periv√§nluokan olio. T√§m√§ tarjoaa monia etuja:

Huom! T√§ss√§ tapauksessa Animal luokan destruktori on m√§√§ritett√§v√§ virtuaaliseksi.
1.1 Polymorfismi

Voit k√§sitell√§ Dog-oliota yleisemm√§ll√§ Animal-tyypill√§. T√§m√§ mahdollistaa koodin kirjoittamisen siten, ett√§ se voi k√§sitell√§ mit√§ tahansa Animal-tyyppist√§ oliota (Dog, Cat, jne.), mik√§ lis√§√§ joustavuutta ja laajennettavuutta.

#include <memory>
#include <vector>

std::vector<std::unique_ptr<Animal>> animals;
animals.push_back(std::make_unique<Dog>());
animals.push_back(std::make_unique<Cat>());
animals.push_back(std::make_unique<Bird>());

for (const auto& animal : animals) {
    animal->callOut();  // Jokainen el√§in toteuttaa oman luokkansa callOut-metodin
}
// Muisti vapautuu automaattisesti, kun animals-vektori tuhoutuu

1.2 Yleisemm√§t funktiot

Funktiot voivat k√§sitell√§ Animal-tyyppisi√§ olioita ilman, ett√§ niiden tarvitsee tiet√§√§ periv√§√§ luokkaa:

void handleAnimal(const std::unique_ptr<Animal>& animal) {
    animal->callOut();  // Polymorfinen kutsu
}

1.3 Laajennettavuus

Voit lis√§t√§ uusia el√§inlajeja (Cat, Bird, jne.) ilman, ett√§ sinun tarvitsee muuttaa vanhaa koodia, joka k√§ytt√§√§ kantaluokkaa (Animal).
2. Periv√§nluokan olio

Periv√§nluokan olio voidaan luoda lauseella: unique_ptr<Dog> dog = make_unique<Dog>();, jolloin k√§ytet√§√§n periv√§nluokan tyyppi√§. T√§m√§ voi olla hy√∂dyllist√§ seuraavissa tilanteissa:

2.1 Periv√§nluokan ominaisuuksien k√§ytt√∂

Jos haluat k√§ytt√§√§ Dog-luokan erityisi√§ metodeja tai j√§senmuuttujia, jotka eiv√§t ole kantaluokassa, sinun t√§ytyy k√§ytt√§√§ Dog-tyyppi√§:

auto dog = std::make_unique<Dog>();
dog->getOwner();  // Ominaisuus, joka on vain Dog-luokassa, ei Animal-luokassa

2.2 Ei tarvitse virtuaalisia funktioita

Jos et tarvitse polymorfismia, suora Dog-osoitin voi olla tehokkaampi, koska se ei aiheuta ylim√§√§r√§ist√§ suorituskykykustannusta virtuaalifunktiotaulun (vtable) k√§yt√∂st√§ (vtable on taulukko, joka sis√§lt√§√§ osoittimet virtuaalisiin metodeihin).
Yhteenveto
Ominaisuus 	unique_ptr<Animal> 	unique_ptr<Dog>
Polymorfismi 	Kyll√§ 	Ei
Koodin joustavuus ja laajennettavuus 	Kyll√§ 	Ei
Periv√§nluokan metodit k√§ytett√§viss√§ 	Ei ilman tyyppimuunnosta 	Kyll√§
Suorituskyky 	Hieman hitaampi (virtuaalitaulu) 	Hieman nopeampi
Muistinhallinta 	Automaattinen 	Automaattinen
Milloin k√§ytt√§√§ unique_ptr<Animal> ja milloin unique_ptr<Dog>?

    K√§yt√§ unique_ptr<Animal>, kun haluat hy√∂dynt√§√§ polymorfismia ja k√§sitell√§ erilaisia el√§inluokkia samalla tavalla.
    K√§yt√§ unique_ptr<Dog>, kun tied√§t tarkalleen, ett√§ ty√∂skentelet vain Dog-olioiden kanssa ja haluat k√§ytt√§√§ sen erityisi√§ metodeja.

Esimerkki 1: Polymorfismi

std::unique_ptr<Animal> animal = std::make_unique<Dog>();
animal->callOut();  // Kutsuu Dog:n toteuttamaa callOut-metodia

Esimerkki 2: Suora k√§ytt√∂

auto dog = std::make_unique<Dog>();
dog->getOwner();  // Erityinen Dog-metodi


√§l√§ anna suoria vastauksia auto ainoastaan  rungossa. √§l√§ n√§yt√§ suoria koodeja tai muita muuttujia. 

ChatGPT sanoi:

Mietti 34s
Aloitetaan t√§m√§ pala kerrallaan ja pidet√§√§n kiinni siit√§, ettet saa suoraa valmista koodia, vaan rungon + idean, jonka t√§yt√§t itse. üôÇ

1. Animal-luokka (kantaluokka)
Tiedostot:

Animal.h ‚Äì luokan m√§√§rittely

Animal.cpp ‚Äì metodien toteutus

Mit√§ Animal.h-tiedostossa on rungollisesti:

Luokkajulistus

Julkinen oletusrakentaja (voi olla tyhj√§)

Virtuaalinen destruktori

Virtuaalinen callOut-metodi (ei puhtaasti virtuaalinen t√§ss√§ teht√§v√§ss√§)

Rakenne-idea, ei t√§yten√§ koodina:

#pragma once tms. yl√§osaan

class Animal {

public:

rakentaja

virtual destruktori

virtual funktio callOut() ilman parametreja, ei paluuarvoa

Toteutuksessa tulostat tekstin, jossa kerrotaan, ett√§ el√§in √§√§ntelee

};

Animal.cpp-tiedostossa:

Sis√§llyt√§ Animalin otsikkotiedosto

Toteuta rakentaja (voi olla tyhj√§)

Toteuta destruktori (voi olla tyhj√§)

Toteuta callOut() siten, ett√§ se tulostaa ohjeen antaman yleisen el√§inviestin

2. Dog-luokka (periv√§ luokka)
Tiedostot:

Dog.h

Dog.cpp

Dog.h rungollisesti:

#pragma once tms.

Sis√§llyt√§ Animal.h

Julista luokka, joka perii julkisesti Animalin

Julkinen osio:

rakentaja

tarvittaessa destruktori (voit merkit√§ sen virtuaaliseksi tai k√§ytt√§√§ oletusta)

callOut()-metodi, joka ylikirjoittaa kantaluokan version

k√§yt√§ override-avainta per√§ss√§, jotta n√§et virheet helposti

Rakenne:

class Dog : public Animal {

public:

rakentaja

destruktori

void callOut() override;

};

Dog.cpp-tiedostossa:

Sis√§llyt√§ Dogin otsikko

Toteuta rakentaja, destruktori

Toteuta callOut() niin, ett√§ se tulostaa koira-viestin (ohjeen tekstin mukaisesti)

3. Polymorfinen k√§ytt√∂ ja olioiden tuhoutuminen
Teht√§v√§nanto pyyt√§√§:

Luomaan Animal-olion

Luomaan Dog-olion

Kutsumaan molemmille callOut()-metodia

Varmistamaan, ett√§ oliot tuhoutuvat oikein

Kaksi tapaa:

3.1 Pino-oliot (ei √§lyosoittimia)
P√§√§funktiossa voit:

luoda tavallisen Animal-olion

luoda tavallisen Dog-olion

kutsua kummallekin callOut()-metodia

kun main loppuu, molemmat oliot tuhoutuvat automaattisesti -> kutsuu vastaavat destruktorit

T√§ll√∂in n√§et ei-polymorfisen tilanteen:

Animal-tyypist√§ olio kutsuu Animalin versiota

Dog-tyypist√§ olio kutsuu Dogin versiota

3.2 Polymorfinen k√§ytt√∂ √§lyosoittimilla
Jos haluat samalla harjoitella polymorfismia:

Lis√§√§ #include <memory> main.cpp:iin

Luo kantaluokan √§lyosoitin, joka osoittaa Dog-olioon; rakenne ajatuksena:

std::unique_ptr<Animal> tyyppinen muuttuja

alustetaan luomalla Dog-olio std::make_unique-funktion avulla

Kutsu callOut() tuon kantaluokka-osoittimen kautta

T√§ll√∂in:

koska callOut on virtuaalinen ja Dog ylikirjoittaa sen,

kutsu menee Dogin toteutukseen, vaikka muuttujan tyyppi on Animal

kun √§lyosoitin menee elinkaarensa loppuun (esim. main p√§√§ttyy),

unique_ptr vapauttaa automaattisesti muistin

Animalin virtuaalinen destruktori takaa, ett√§ my√∂s Dogin destruktori kutsutaan oikein

Voit halutessasi lis√§ksi:

luoda suoran std::unique_ptr<Dog>-muuttujan ja kutsua callOut() silt√§ -> ei polymorfiaa, mutta Dogin oma tyyppi k√§yt√∂ss√§ ja voit k√§ytt√§√§ Dogin omia lis√§metodeja, jos sellaisia keksit.

4. Mit√§ kannattaa viel√§ varmistaa
Kun olet kirjoittanut rungon itse:

K√§√§nn√§ projekti ‚Äì virheilmoituksista n√§et helposti:

puuttuuko override-merkint√§

onko otsikkotiedosto sis√§llytetty oikein

Aja ohjelma ja tarkista:

ett√§ Animal-olion callOut tulostaa yleisen viestin

ett√§ Dog-olion callOut tulostaa koirakohtaisen viestin

ett√§ polymorfisessa tapauksessa (Animal-osoitin ‚Üí Dog-olio) ruudulle tulee Dogin viesti

Jos haluat, seuraavassa vaiheessa voimme katsoa vain main-funktion rakenneskeletin (ilman konkreettisia rivej√§), ja voit itse t√§ydent√§√§ sen ‚Äì tai voit n√§ytt√§√§ oman yrityksesi niin kommentoin, mit√§ siihen kannattaa korjata.

Sin√§ sanoit:
1\. Animal-luokka (kantaluokka) ------------------------------- **Tiedostot:** * `Animal.h` ‚Äì luokan m√§√§rittely * `Animal.cpp` ‚Äì metodien toteutus **Mit√§ `Animal.h`\-tiedostossa on rungollisesti:** * Luokkajulistus * Julkinen oletusrakentaja (voi olla tyhj√§) * **Virtuaalinen destruktori** * **Virtuaalinen** `callOut`\-metodi (ei puhtaasti virtuaalinen t√§ss√§ teht√§v√§ss√§) Rakenne-idea, ei t√§yten√§ koodina: * `#pragma once` tms. yl√§osaan * `class Animal {` * `public:` * rakentaja * `virtual` destruktori * `virtual` funktio `callOut()` ilman parametreja, ei paluuarvoa * Toteutuksessa tulostat tekstin, jossa kerrotaan, ett√§ el√§in √§√§ntelee * `};` **Animal.cpp**\-tiedostossa: * Sis√§llyt√§ Animalin otsikkotiedosto * Toteuta rakentaja (voi olla tyhj√§) * Toteuta destruktori (voi olla tyhj√§) * Toteuta `callOut()` siten, ett√§ se **tulostaa ohjeen antaman yleisen el√§inviestin**

one step a time. lets take it slow, so i can understand what i m doing.

-header
#ifndef ANIMAL_H
#define ANIMAL_H
#include <string>

class animal{
private:
    std::string name;
    
public:
    animal();
    ~animal();
    void callout();
};

#endif // ANIMAL_H
ChatGPT sanoi:

Mietti 26s
Hyv√§, just n√§in ‚Äì otetaan t√§m√§ tosi rauhassa ja katsotaan vain mit√§ pit√§√§ muuttaa, ei valmista koodipalaa.

Sun header on nyt:

#ifndef ANIMAL_H
#define ANIMAL_H
#include <string>

class animal{
private:
    std::string name;
    
public:
    animal();
    ~animal();
    void callout();
};

#endif // ANIMAL_H
K√§yd√§√§n muutokset kohta kohdalta.

1. Nimi ja tyyli
Teht√§v√§ss√§ puhuttiin luokasta Animal, isolla A:lla.

üîß Muuta:

Rivill√§, jossa on class animal{, vaihda luokan nimi muotoon, jossa:

alkaa isolla kirjaimella

vastaa tarkalleen teht√§v√§n nime√§

Samoin rakentajan ja destruktorin nimet pit√§√§ olla t√§sm√§lleen sama kuin luokan nimi:

rakenne: luokan nimi ilman paluuarvoa

destruktori: sama nimi, mutta ~-merkki edess√§

Eli: kun vaihdat luokan nimen, muista vaihtaa se my√∂s rakentajan ja destruktorin riveill√§.

2. Tarvitsetko name-kentt√§√§?
Teht√§v√§ ei vaadi nime√§ ollenkaan ‚Äì se puhuu vain callOut-metodista, joka tulostaa yleisen tekstin.

Sinulla on nyt:

yksityinen j√§senmuuttuja std::string name;

#include <string>

Vaihtoehdot:

Helpoin: jos et tarvitse nime√§ miss√§√§n, voit

poistaa t√§m√§n yksityisen j√§senmuuttujan

poistaa my√∂s #include <string>-rivin, koska sit√§ ei en√§√§ tarvita

(Polymorfismiharjoitusta ajatellen nimi ei tuo lis√§arvoa.)

Jos haluat s√§ilytt√§√§ nimen, sekin on ok, mutta sitten my√∂hemmin rakentajassa ja mahdollisesti callOutissa voit k√§ytt√§√§ sit√§. Valitse kumpi tuntuu paremmalta, mutta yksinkertaisuuden vuoksi suosittelen alkuun poistamaan nimen.

3. Virtuaalinen destruktori
Teht√§v√§ss√§ painotettiin, ett√§ kantaluokan destruktorin pit√§√§ olla virtuaalinen, jotta polymorfia toimii oikein √§lyosoittimien kanssa.

Sinulla on nyt:

destruktori ilman virtual-sanaa

üîß Muuta destruktorin julistusta niin, ett√§:

sen alkuun lis√§t√§√§n avainsana, joka tekee siit√§ virtuaalisen (sama sana, jota k√§ytet√§√§n virtuaalifunktioissa)

nimi ja sulut pysyv√§t samoina kuin luokan nimiin sovitetut

Sanallisesti:

"Lis√§√§ sana virtual destruktorin eteen sen julistuksessa."

4. Virtuaalinen callOut-metodi
Teht√§v√§ss√§ my√∂s callOut pit√§√§ olla virtuaalinen, jotta Dog-luokka voi ylikirjoittaa sen polymorfisesti.

Sinulla on nyt:

void callout();
(huomaa: pieni o ja erilainen kirjainkoko kuin teht√§v√§n callOut)

üîß Tee kaksi asiaa:

Vaihda metodin nimi samaan muotoon kuin teht√§v√§ss√§ (kirjainkoko mukaan lukien: iso O vai pieni o? Pid√§ se t√§sm√§lleen samana kuin ohjeessa).

Lis√§√§ metodin alkuun sama virtuaali-avainsana, jota k√§ytit destruktorille.

Eli:

"Metodin nimen pit√§isi olla callOut, ja sen edess√§ pit√§isi olla virtual."

5. Yhteenveto teht√§vist√§ sinulle
Tee n√§m√§ muutokset Animal.h-tiedostoon:

Vaihda luokan nimen kirjoitusasu vastaamaan teht√§v√§n Animal-nime√§ ja p√§ivit√§ nimi my√∂s rakentajassa ja destruktorissa.

P√§√§t√§, k√§yt√§tk√∂ name-j√§sent√§:

jos et, poista std::string name; ja #include <string>

Lis√§√§ virtual-avainsana:

destruktorin julistukseen

callOut-metodin julistukseen

Vaihda callout ‚Üí callOut (t√§sm√§lleen sama nimi kuin ohjeessa).

Kun olet tehnyt n√§m√§ ja haluat, laita p√§ivitetty headeri t√§nne (tai kerro sanallisesti mit√§ muutit), niin katsotaan seuraavassa vaiheessa Animal.cpp rungon l√§pi samalla hitaalla tahdilla.

Sin√§ sanoit:
√§l√§ anna palautteessa korjaus metodia. ilmoita VAIN mitk√§ kohdat ovat v√§√§rin. etsin itse korjaus metodin. anna vain korjattu malli, jos sit√§ pyydet√§√§n erikseen
ChatGPT sanoi:
Ymm√§rretty ‚Äî jatkossa en anna korjaustapaa, vaan listaan vain virheelliset kohdat.

Tarkastan siis sinun Animal-headerisi ja kerron vain, mitk√§ kohdat ovat pieless√§.

VIRHEELLISET KOHDAT Animal-headerissasi
Luokan nimi ei vastaa teht√§v√§nannon mukaista kirjoitusasua.

Rakentajan nimi ei vastaa luokan nime√§.

Destruktorin nimi ei vastaa luokan nime√§ eik√§ ole virtuaalinen.

callOut-metodin nimi ei vastaa teht√§v√§nannon kirjoitusasua.

callOut-metodi ei ole virtuaalinen.

string-j√§sen ei kuulu teht√§v√§nannon vaatimuksiin (ei ole pakollinen).

include <string> ei ole tarpeellinen, jos edellinen j√§sen poistetaan.

Jos haluat, voit l√§hett√§√§ seuraavan version tarkistettavaksi, ja annan taas vain listan v√§√§rist√§ kohdista.

Sin√§ sanoit:
#ifndef ANIMAL_H
#define ANIMAL_H
#include <string>

class animal{
private:
    std::string name;
    
public:
    animal();
   virtual ~animal();
   virtual void callOut();
};

#endif // ANIMAL_H
ChatGPT sanoi:
Vialliset / ohjeesta poikkeavat kohdat t√§ss√§ versiossa:

Luokan nimi ei vastaa teht√§v√§nannon luokan nimen kirjoitusasua.

Rakentajan nimi ei vastaa luokan nime√§.

Yksityinen j√§sen std::string name; ei kuulu teht√§v√§nannon vaatimuksiin (ei ole tarpeellinen t√§ss√§ harjoituksessa).

#include <string> ei ole tarpeellinen, jos edell√§ mainittua j√§sent√§ ei k√§ytet√§.

Sin√§ sanoit:
header on kunnossa jatketaan cpp tiedostosta
ChatGPT sanoi:
Hyv√§ ‚Äî jatketaan Animal.cpp-toteutukseen, mutta samalla tavalla kuin aiemmin:
en anna valmista koodia, en metodia, en rivej√§. Vain rakenne- ja tarkistusohjeita.

Jotta voimme edet√§ vaihe vaiheelta, tarvitset kaksi vaihtoehtoa:

‚úîÔ∏è Vaihtoehto A ‚Äî N√§yt√§t oman Animal.cpp-tiedostosi
Jos l√§het√§t Animal.cpp:n nykyisen sis√§ll√∂n,
‚Üí annan vain listan virheellisist√§ kohdista, aivan kuten headerin kanssa.
En anna korjaustapaa ennen kuin sit√§ erikseen pyyd√§t.

‚úîÔ∏è Vaihtoehto B ‚Äî Haluat ohjeen ilman, ett√§ l√§het√§t tiedostoa
Jos haluat jatkaa ilman, ett√§ n√§yt√§t cpp:t√§, voin kertoa:

mit√§ asioita Animal.cpp:ss√§ t√§ytyy rungollisesti olla,

ilman rivej√§, ilman konkreettista syntaksia.

Kumpi tapa sopii seuraavaksi?

Sin√§ sanoit:
#include "animal.h"
#include <iostream>

animal::animal(){
    std::cout << "El√§in √§√§ntelee" << std::endl;

this is not right, i know for sure. doesnt "el√§in √§√§ntelee" part be to bind to something so we can change it later or
ChatGPT sanoi:
Tarkistan vain virheelliset kohdat t√§st√§, en anna korjausmetodeja:

‚ùå V√Ñ√ÑR√ÑT / POIKKEAVAT KOHDAT Animal.cpp:ss√§si
Luokan nimi toteutuksessa ei vastaa headerissa vaadittua nime√§.

Rakentajaan ei kuulu mit√§√§n tulostusta teht√§v√§nannon mukaan.

callOut-metodin toteutusta ei n√§y lainkaan.

Teksti "El√§in √§√§ntelee" on sijoitettu v√§√§r√§√§n paikkaan (ei kuulu rakentajaan).

Jos haluat, voit n√§ytt√§√§ koko Animal.cpp:n (kaikki metodi¬≠runkojen alut mukana), niin voin listata loputkin mahdolliset virheet.

Sin√§ sanoit:
anna vihje rakenteesta
ChatGPT sanoi:
T√§ss√§ rakennevihje, joka ei sis√§ll√§ koodia eik√§ rivej√§, mutta kertoo mit√§ Animal.cpp:n osien kuuluu olla ja mihin j√§rjestykseen ne yleens√§ tulevat:

üß© Animal.cpp rakenteen idea
Sis√§llyt√§ Animalin header
‚Äì T√§m√§ kertoo k√§√§nt√§j√§lle, mit√§ metodeja sinun pit√§√§ toteuttaa.

Rakentajan toteutus
‚Äì Rakenne on tyhj√§ tai tekee vain luokan sis√§isi√§ alkuasetuksia.
‚Äì Ei tulosta mit√§√§n, koska callOut on se joka √§√§nt√§√§.

Destruktorin toteutus
‚Äì Sama juttu: yleens√§ tyhj√§, ellei ole erityist√§ siivottavaa.
‚Äì Ei tulosta mit√§√§n teht√§v√§nannossa.

callOut-metodin toteutus
‚Äì T√§m√§ on se paikka, jossa Animal-luokan oletus√§√§ni tulostetaan.
‚Äì T√§ss√§ toteutuksessa kuuluu olla se yksi lause, jonka ohje antoi.
‚Äì T√§m√§ on se funktio, jonka Dog tulee my√∂hemmin ylikirjoittamaan.

üîç K√§yt√§nn√∂n ajatusvirta
Headerissa julistit kolme funktiota: rakentajan, destruktorin ja callOutin.

Animal.cpp:
‚Äì Toteutat jokaisen niist√§, samassa j√§rjestyksess√§ kuin headerissa.

Ainoa paikka, jossa Animal tulostaa oman √§√§nens√§:
‚Üí callOut, ei rakentaja.

Jos haluat, voit nyt tehd√§ oman version Animal.cpp:st√§ t√§m√§n rakenteen perusteella ja l√§hett√§√§ sen ‚Äî listaan taas vain virheelliset kohdat.

Sin√§ sanoit:
kyll√§ kiitos
ChatGPT sanoi:
Hienoa ‚Äî silloin jatketaan samalla tavalla kuin aiemmin.
Jotta voin tarkistaa seuraavan vaiheen vain listaamalla virheet, tarvitsen sinulta:

üëâ Animal.cpp-tiedoston version, jonka teit √§skeisen rakennevihjeen perusteella.

Kun l√§het√§t sen, vastaan:

vain listalla asioista, jotka ovat v√§√§rin tai poikkeavat ohjeesta,

ilman korjaustapaa,

ja menn√§√§n askel kerrallaan eteenp√§in.

Sin√§ sanoit:
#include "animal.h"
#include <iostream>

animal::animal(){
    
    std::cout << callOut() << std::endl;
}
animal::~animal(){
    }

voi animal::callOut(){
    
}    

poikkeus t√§ss√§ kohdassa anna malli esimerkki ja kerro jokainen koodi erikseen selitt√§en sen toiminta
ChatGPT sanoi:
Selv√§ ‚Äî koska sanoit erikseen ‚Äúanna malli esimerkki‚Äù, voin nyt antaa t√§yden mallin Animal.cpp-rakenteesta ja selitt√§√§ jokaisen osan erikseen.
(Et ole pyyt√§nyt viel√§ Dog-luokan mallia, joten annan vain Animal.cpp:n.)

Alla esimerkki t√§sm√§lleen oikeasta rakenteesta:

‚úÖ Oikea malliesimerkki: Animal.cpp
#include "animal.h"
#include <iostream>

// Rakentaja
Animal::Animal() {
    // Ei tehd√§ mit√§√§n erityist√§
}

// Destruktori
Animal::~Animal() {
    // Ei tehd√§ mit√§√§n erityist√§
}

// Virtuaalinen callOut-metodin toteutus
void Animal::callOut() {
    std::cout << "El√§in √§√§ntelee." << std::endl;
}
üîç Selitys rivi rivilt√§
1. Headerin sis√§llytys
#include "animal.h"
T√§m√§ liitt√§√§ luokan m√§√§rittelyn (= Animal-luokan julistuksen).

Ilman t√§t√§ CPP-tiedosto ei tiet√§isi, mit√§ metodeja sinun pit√§√§ toteuttaa.

2. I/O-kirjasto
#include <iostream>
Tarvitaan, koska k√§yt√§t std::cout.

Tulostustoiminto tulee t√§st√§.

3. Rakentaja
Animal::Animal() {
    // Ei tehd√§ mit√§√§n erityist√§
}
Rakentaja kutsutaan kun luokan olio luodaan.

T√§ss√§ harjoituksessa ei tarvitse tehd√§ mit√§√§n.

T√ÑRKE√Ñ√Ñ: Rakentaja EI tulosta √§√§nt√§.
‚Üí √§√§ni kuuluu callOut-metodiin, jotta Dog voi ylikirjoittaa sen.

4. Destruktori
Animal::~Animal() {
    // Ei tehd√§ mit√§√§n erityist√§
}
Kutsutaan, kun olio tuhoutuu.

Ei tarvitse tulostaa mit√§√§n.

Destruktori on headerissa virtual, jotta polymorfinen tuhoutuminen toimii.

5. callOut-metodi
void Animal::callOut() {
    std::cout << "El√§in √§√§ntelee." << std::endl;
}
T√§m√§ on virtuaalinen metodi headerissa.

T√§m√§ on se metodi, jonka Dog-luokka ylikirjoittaa.

Tulostaa Animalin oletus√§√§nen.

Polymorfismi toimii niin, ett√§ jos sinulla on:

std::unique_ptr<Animal> a = std::make_unique<Dog>();
a->callOut();
kutsu ohjautuu Dog::callOut-versioon.

üîö Mit√§ korjasimme sinun alkuper√§isess√§ versiossasi
Selit√§n, miksi sinun koodisi ei toiminut:

‚ùå Virhe 1 ‚Äî Rakentajasta yritettiin tulostaa callOutin palautusarvo
std::cout << callOut() << std::endl;
callOut() ei palauta mit√§√§n ‚Üí ei voi tulostaa.

callOut tulostaa itse, sit√§ ei tulosteta cout << kautta.

‚ùå Virhe 2 ‚Äî callOut-metodin runko puuttui
voi animal::callOut(){
    
}
T√§ss√§ oli kirjoitusvirhe (voi ‚Üí void).

My√∂s luokan nimi oli v√§√§r√§ (iso A puuttui).

Sis√§lt√∂ puuttui kokonaan.

‚ùå Virhe 3 ‚Äî √§√§ni oli v√§√§r√§ss√§ metodissa
√§√§nen pit√§√§ tulla callOutissa, ei rakentajassa.

‚úîÔ∏è Jos haluat, seuraavaksi voimme tehd√§ saman Dog.cpp:lle
N√§yt√§t oman version ‚Üí listaan virheet ‚Üí
ja vasta kun pyyd√§t, annan t√§ydellisen mallin + selitykset samalla tavalla kuin nyt.

Sopiiko?

Sin√§ sanoit:
Rakenne: * `class Dog : public Animal {` * `public:` * rakentaja * destruktori * `void callOut() override;` * `};`

t√§m√§ tyyli paljastaa liikaa. 

#include "dog.h"
#include <iostream>

dog::dog() {}

dog::~dog(){}
 void callOut();

void animal::callOut()
    std::cout << "Koira haukkuu" << std::endl;

in this how should i do this. callout. by getting the callout from animal file ?
ChatGPT sanoi:
Selv√§ ‚Äî nyt menn√§√§n tosi varovaisesti, niin ettei paljasteta liikaa ja ettei ratkaisu ole liian suora. Kerron vain mik√§ Dog.cpp:ss√§si on rikki ja mit√§ pit√§isi ymm√§rt√§√§ konseptina, ei koodiesimerkki√§.

‚ùå Tarkistus: Mitk√§ kohdat Dog.cpp:ss√§si ovat v√§√§rin
Luokan nimi on v√§√§r√§ss√§ muodossa (kirjainkoko ei vastaa otsikkotiedoston luokan nime√§).

callOut-metodin toteutus ei ole sidottu Dog-luokkaan.

callOut-metodin m√§√§rittely ei k√§yt√§ oikeaa luokkakohtaista syntaksia.

callOut-metodin rivi, jossa lukee void callOut();, ei kuulu cpp-tiedostoon.

Ei toteuteta Dog-luokan versiota callOutista, vaan yrit√§t toteuttaa Animal-luokan version Dog.cpp:ss√§.

Puuttuu Dog-luokan callOut-metodin runko, joka ylikirjoittaa Animal::callOutin.

Rakenne on v√§√§r√§: Animalin toteutus ei kuulu Dog.cpp:√§√§n lainkaan.

üîç Vastaus kysymykseesi konseptitasolla
"How should I do this? callOut. By getting the callOut from animal file?"

T√§ss√§ vastaus ilman koodia:

‚úîÔ∏è Dog-luokan callOut ei hae Animalin callOutia.
‚Üí Se ylikirjoittaa sen.

‚úîÔ∏è Sinun t√§ytyy toteuttaa Dogin oma callOut-metodi Dog.cpp:ss√§
‚Üí Ei Animal.cpp:ss√§
‚Üí Ei Dogin rakentajassa
‚Üí Ei irrallisena funktiona

‚úîÔ∏è Dogin callOut-metodi tehd√§√§n samalla tavalla kuin Animalin callOut
Mutta:

Nimi on sama (callOut)

Luokan nimi vaihdetaan Dogiksi

Sis√§lt√∂ tulostaa koiran version

override on kerrottu headerissa, mutta cpp:ss√§ ei k√§ytet√§ override-sanaa

‚ùó T√§rke√§ periaate:
Animal.cpp sis√§lt√§√§ vain Animal-metodit.
Dog.cpp sis√§lt√§√§ vain Dog-metodit.

Et koskaan toteuta Animalin metodia Dog.cpp:ss√§.

üß† Konseptivihje toteutustavasta
Dog.cpp:ssa pit√§√§ olla kolme osaa:

Dogin rakentaja

Dogin destruktori

Dogin oma callOut-metodi

joka korvaa Animalin version

ja tulostaa koiran √§√§nen

Ei Animal-metodeja, ei irrallisia funktioita, ei ylim√§√§r√§isi√§ puolivalmiita julistuksia.

Jos haluat, voit nyt korjata Dog.cpp:n rakenteen itse ja l√§hett√§√§ uuden version ‚Üí
annan taas vain listan virheist√§, jotta voit itse l√∂yt√§√§ korjaukset.

Sin√§ sanoit:
#include "dog.h"
#include <iostream>

dog::dog() {}

dog::~dog(){}


void dog::callOut(){
    std::cout << "Koira haukkuu" << std::endl;
}

ChatGPT sanoi:
Tarkastan t√§m√§n version ja annan vain virheelliset kohdat, kuten pyysit ‚Äî ei korjaustapoja, ei koodia.

‚ùå Virheelliset / poikkeavat kohdat Dog.cpp:ss√§si
Luokan nimi ei vastaa teht√§v√§nannon luokan nimen kirjoitusasua (kirjainkoko).

Rakentajan nimi ei vastaa luokan nime√§ (kirjainkoko).

Destruktorin nimi ei vastaa luokan nime√§ (kirjainkoko).

callOut-metodin toteutuksen alkuosa ei k√§yt√§ samaa luokan nime√§ kuin header.

Teksti√§ ei ole p√§√§tetty pisteell√§ kuten teht√§v√§nanto ohjeessa (pieni huomio, mutta ero on).

Kun haluat, voit l√§hett√§√§ korjatun version seuraavaksi ‚Äî tarkistan taas vain virheet.

Sin√§ sanoit:
luokan nimi dog on hyv√§. √§l√§ v√§lit√§ t√§st√§
ChatGPT sanoi:
Selv√§ ‚Äî jos luokan nimi dog on tarkoituksella juuri noin, en huomioi sit√§ virheen√§.

Tarkastan siis Dog.cpp:n uudelleen, t√§ll√§ kertaa j√§tt√§en nimen kokonaan huomiotta.

‚ùå Virheet Dog.cpp-tiedostossa (LUOKAN NIME√Ñ EI OTETA HUOMIOON)
callOut-metodin sis√§lt√∂ ei vastaa teht√§v√§nannon lauseen tarkkaa muotoa.

Metodin sis√§inen teksti puuttuu teht√§v√§nannossa oleva piste lopusta.

Jos haluat, voit l√§hett√§√§ seuraavan version ja tarkistan uudelleen vain virheet.

Sin√§ sanoit:
#include "dog.h"
#include <iostream>

dog::dog() {}

dog::~dog(){}


void dog::callOut(){
    std::cout << "Koira haukkuu." << std::endl;
}
ChatGPT sanoi:
Tarkastan koodin taas s√§√§nt√∂jen mukaan (luokan nimen muotoa ei huomioida virheen√§).

‚úÖ Virheet Dog.cpp-tiedostossa:
Ei virheit√§.

Kaikki t√§m√§n harjoituksen vaatimukset t√§yttyv√§t t√§m√§n tiedoston osalta.

Kun haluat, voimme siirty√§ seuraavaan vaiheeseen:
üëâ main.cpp rungon tarkistus samalla tyylill√§ (vain virhelista).

Sin√§ sanoit:
#include <memory>
#include <vector>
#include "animal.h"
#include "dog.h"
#include <iostream>

using namespace std;

int main(){
    
    std::vector<std::unique_ptr<animal>> animals;
    animals.push_back(std::make_unique<dog>());
    //animals.push_back(std::make_unique<Cat>());
    //animals.push_back(std::make_unique<Bird>());
}
    for (const auto& animal : animals) {
        animal->callOut();  // Jokainen el√§in toteuttaa oman luokkansa callOut-metodin
    }


EI teht√§v√§ annon mukainen. Mutta anna virheet
ChatGPT sanoi:
Tarkastetaan vain virheet, ei korjauksia eik√§ oikeaa mallia.

‚ùå Virheet main.cpp-tiedostossasi
Tietorakenne k√§ytt√§√§ v√§√§r√§√§ kantaluokkatyyppi√§.
‚Äì Vektorissa on unique_ptr<animal>, mutta teht√§v√§nannon luokan nimi on eri kirjoitusasulla.

Silmukka on koodilohkon ulkopuolella.
‚Äì for-silmukka on main-funktion ulkopuolella.

Silmukka viittaa muuttujaan, joka ei ole sen n√§kyvyysalueessa.
‚Äì animals ei ole k√§ytett√§viss√§ silmukan kohdassa.

main-funktio ei kutsu callOut-metodia teht√§v√§nannon pyyt√§m√§ll√§ tavalla.
‚Äì Ei ole yksitt√§isi√§ olioita (Animal + Dog) eik√§ niille tehty kutsuja.

main-funktion rakenne ei vastaa teht√§v√§nannon pyynt√∂√§ luoda kaksi oliota (yksi Animal, yksi Dog).

Kommentoidut Cat ja Bird viittaavat luokkiin, joita ei ole teht√§v√§ss√§.

Koodilohkojen sulkujen j√§rjestys ei ole oikein.

Jos haluat, voit tehd√§ uuden version mainista ja tarkistan sen taas virhelistalla.

Sin√§ sanoit:
#include <memory>
#include "animal.h"
#include "dog.h"
#include <iostream>

using namespace std;

int main(){

    unique_ptr<Dog> dog = make_unique<Dog>();
    
    
    
}

ChatGPT sanoi:
Tarkastetaan t√§m√§ vain virheiden listauksena, ei korjauksia eik√§ koodia tilalle.

‚ùå Virheet main.cpp-tiedostossasi
Luokkanimen kirjoitusasu ei vastaa omaa Dog-luokkaasi.
‚Äì K√§yt√§t Dog, vaikka projektissasi luokan nimi on aiemmissa esimerkeiss√§ ollut eri muodossa.

Teht√§v√§nannon vaatimaa Animal-olion luontia ei ole.

Teht√§v√§nannon vaatimaa Dog-olion callOut-kutsua ei ole.

Teht√§v√§nannon vaatimaa Animal-olion callOut-kutsua ei ole.

Teht√§v√§ ei pyyt√§nyt polymorfista smart pointer -k√§ytt√∂√§ Dog-luokan kautta, vaan
‚Äì Animal-olio + Dog-olio
‚Äì ja molempien callOut-kutsut.

main-funktiossa ei tapahdu mit√§√§n muuta kuin olion luonti, eli ohjelma ei tee teht√§v√§annon mukaista toimintaa.

Ei ole varmistusta siit√§, ett√§ Animal-luokan ja Dog-luokan destruktorit kutsutaan, koska Animal-olion luonti puuttuu kokonaan.

Kun haluat, voit tehd√§ uuden version ‚Äî tarkistan sen taas samalla tavalla vain virhelistauksena.

Sin√§ sanoit:
#include <memory>
#include "animal.h"
#include "dog.h"
#include <iostream>

using namespace std;

int main(){
    
    Animal elain1 ();
    Dog koira1 ();
    
    elain1.callOut();
    koira1.callOut();
    
    
}


t√§h√§n suuntaanko =
ChatGPT sanoi:
Tarkastetaan t√§m√§ saman s√§√§nn√∂n mukaan kuin ennen:
üëâ vain virheelliset kohdat, ei korjaustapaa eik√§ oikeaa koodia.

‚ùå Virheet main.cpp-versiossasi
Olioiden luonti on v√§√§r√§ss√§ muodossa.
‚Äì Kirjoitustapa Animal elain1 (); ja Dog koira1 (); ei luo olioita, vaan julistaa funktiot.

Luokkanimien kirjoitusasu ei vastaa aiempaa toteutustasi.
‚Äì K√§yt√§t Animal ja Dog, vaikka projektissasi luokan nimet ovat eri muodossa (aiemmissa tiedostoissa oli pienell√§ alkukirjaimella).

Teht√§v√§nannossa ei k√§ytet√§ sulkuja olion luonnissa, ellei parametreja ole.

Nimi elain1 ei vastaa teht√§v√§nannon englanninkielist√§ nime√§mistyyli√§, mutta t√§m√§ on pieni huomio.

Jos haluat, tee seuraava versio main.cpp:st√§ ‚Äî tarkistan taas vain virheet.

Sin√§ sanoit:
anna esimerkki koodi
ChatGPT sanoi:
T√§ss√§ kohtaa pyysit suoraan esimerkkikoodia, joten nyt voin antaa sen kokonaisena ilman rajoituksia.

Alla on t√§ysin toimiva esimerkki, joka vastaa t√§sm√§lleen teht√§v√§nantoa:

luodaan Animal-olio

luodaan Dog-olio

kutsutaan molempien callOut

k√§ytet√§√§n stack-olioita, ei smart pointereita (koska teht√§v√§ ei vaadi niit√§)

nimet ovat isolla alkukirjaimella, koska se on vakiok√§yt√§nt√∂ C++-luokissa

‚úÖ VALMIS MAIN.CPP ‚Äì ESIMERKKIKOODI
#include <iostream>
#include "animal.h"
#include "dog.h"

int main() {
    Animal elain1;   // luo Animal-olion
    Dog koira1;      // luo Dog-olion

    elain1.callOut();   // tulostaa: El√§in √§√§ntelee.
    koira1.callOut();   // tulostaa: Koira haukkuu.

    return 0;
}
üìå Selitys
Animal elain1;
Luo kantaluokan olion.

Kun kutsut elain1.callOut() ‚Üí suoritetaan Animalin versio.

Dog koira1;
Luo perityn luokan olion.

Kun kutsut koira1.callOut() ‚Üí suoritetaan Dog-luokan ylikirjoitettu versio.

Polymorfia ei ole t√§ss√§ pakollinen
Teht√§v√§nanto ei viel√§ vaadi smart pointereita, joten t√§m√§ versio t√§ytt√§√§ kaikki vaatimukset.

Jos haluat, voin antaa my√∂s polymorfisen version (unique_ptr ja Animal-tyyppinen osoitin), mutta t√§m√§ on juuri se, mit√§ harjoitus 3b pyyt√§√§.

Sin√§ sanoit:
tarkempi selitys. jokainen koodin kohta paitsi #includes pit√§√§ selitt√§√§
ChatGPT sanoi:
T√§ss√§ tulee eritt√§in tarkka, kohta kohdalta etenev√§ selitys, jossa selit√§n jokaisen rivin ja elementin paitsi include-rivien, kuten pyysit.
Selit√§n my√∂s, mit√§ C++ tekee taustalla.

Koodi, jota selit√§mme:

int main() {
    Animal elain1;
    Dog koira1;

    elain1.callOut();
    koira1.callOut();

    return 0;
}
üîç SELITYS ‚Äì RIVI RIVILT√Ñ
üí† int main() {
T√§m√§ aloittaa ohjelman p√§√§funktion.

main on se kohta, josta C++-ohjelma k√§ynnistyy.

int tarkoittaa, ett√§ funktio palauttaa lopuksi kokonaisluvun k√§ytt√∂j√§rjestelm√§lle.

Arvo 0 = kaikki meni oikein.

üí† Animal elain1;
Mit√§ t√§ss√§ tapahtuu?
Luodaan Animal-luokan olio nimelt√§ elain1.
‚Äì T√§t√§ kutsutaan pino-olioksi (stack object).

C++ suorittaa automaattisesti Animal-luokan rakentajan.
‚Äì T√§m√§ on se funktio Animal::Animal(), jonka kirjoitit Animal.cpp:√§√§n.

Olio elain1 syntyy ja el√§√§ main-funktion lohkon sis√§ll√§ (lohko on {}-sis√§lt√∂).

Miksi t√§m√§ on t√§rke√§√§?
T√§m√§ on ensimm√§inen olio, jota k√§yt√§t kutsumaan Animalin callOut-metodia.

Jokainen Animal-olio (my√∂s ne, joista perit√§√§n) saa oman erillisen elinkaaren.

üí† Dog koira1;
Mit√§ t√§ss√§ tapahtuu?
Luodaan Dog-luokan olio nimelt√§ koira1.
‚Äì T√§m√§ olio perii Animalin, koska Dog : public Animal.

C++ suorittaa seuraavan ketjun:

ensin Animal-luokan rakentaja

sen j√§lkeen Dog-luokan rakentaja

T√§m√§ on aina perint√§luokassa:

Kantaluokka rakentuu ensin ‚Üí sitten periv√§ luokka.

Nyt koira1-oliolla on:

Animal-luokan ominaisuudet

Dog-luokan omat ominaisuudet

ylikirjoitettu callOut-metodi

üí† elain1.callOut();
Mit√§ tapahtuu?
Kutsut elain1-olion kautta Animal-luokan callOut-metodia.

Koska elain1 on Animal-tyyppi√§, C++ k√§ytt√§√§ Animalin versiota funktiosta.

Tulostuu Animal.cpp:n sis√§ll√∂n mukainen lause:

"El√§in √§√§ntelee."

Miksi t√§m√§ on t√§rke√§√§?
T√§m√§ n√§ytt√§√§, ett√§ kantaluokan oma toiminta toimii sellaisenaan.

T√§ss√§ ei ole polymorfiaa ‚Äî t√§m√§ on suora kutsu.

üí† koira1.callOut();
Mit√§ tapahtuu?
Kutsut callOut-metodia Dog-olion kautta.

Koska Dog on ylikirjoittanut Animalin metodin:

C++ valitsee Dog-luokan version callOut-funktiosta.

Tulostuu Dog.cpp:ss√§ m√§√§ritelty lause:

"Koira haukkuu."

Miksi t√§m√§ on t√§rke√§√§?
T√§m√§ demonstroi ylikirjoittamista (method overriding).

T√§ss√§ ei tarvita polymorfiaa, koska olio on Dog-tyyppi√§.

üí† return 0;
Palautetaan arvo 0 k√§ytt√∂j√§rjestelm√§lle.

T√§m√§ kertoo: ‚ÄúOhjelma p√§√§ttyi onnistuneesti‚Äù.

üí† } (main-funktion lopetus)
Kun t√§t√§ sulku-merkki√§ vasten ohjelman suoritus poistuu mainista:

Dog-olion koira1 tuhoutuu ensin

Kutsutaan Dog-luokan destruktori (~Dog())

Sitten Animal-luokan destruktori (~Animal()), koska Dog perii Animalin

Animal-olion elain1 tuhoutuu sen j√§lkeen

Kutsutaan Animal-luokan destruktori

Miksi t√§m√§ on t√§rke√§√§?
Se demonstroi, ett√§ tuhoamisketju toimii oikein.

Dog-luokan destruktori toimii ensin, Animal-luokan destruktori lopuksi.

üìå Yhteenveto ‚Äî mit√§ t√§m√§ pieni main tekee?
Luo Animal-olion ‚Üí kutsuu sen √§√§nt√§.

Luo Dog-olion ‚Üí kutsuu Dogin ylikirjoitettua √§√§nt√§.

N√§ytt√§√§ periytymisen, ylikirjoittamisen ja tuhoamisen j√§rjestyksen.

T√§sm√§lleen sit√§, mit√§ teht√§v√§ 3b pyyt√§√§.

Jos haluat, voin selitt√§√§ seuraavaksi:

miten polymorfinen versio tehd√§√§n

miten smart pointerit toimivat

miksi destruktori pit√§√§ olla virtual

miten kantaluokan osoitin voi kutsua Dogin metodin

Sano vain!

Sin√§ sanoit:
kyll√§ kiitos
ChatGPT sanoi:
Mahtavaa ‚Äî menn√§√§n seuraavaksi polymorfiaan, smart pointereihin ja siihen, miksi virtuaalinen destruktori on v√§ltt√§m√§t√∂n.
Pid√§n selityksen askelittain, ilman koodia, kunnes pyyd√§t esimerkki√§.

üî∂ 1. Mit√§ polymorfia tarkoittaa?
Polymorfia = kantaluokan osoitin tai smart pointer voi viitata periv√§n luokan olioon.

Ajattele n√§in:

Sinulla on ‚Äúel√§in‚Äù (Animal), mutta et tied√§ mik√§ laji.

Kysyt el√§imelt√§ callOut().

Jos se on Dog, se haukkuu.

Jos se on Cat, se naukuu.

Jos se on Bird, se visert√§√§.

Sama Animal-osoitin ‚Üí eri √§√§ni riippuen siit√§, mik√§ olio on sen sis√§ll√§.

üî∂ 2. Miksi tarvitsemme virtuaalisen metodin?
Polymorfia toimii vain, jos metodi on:

virtual void callOut();
Ilman virtualia:

kutsu menee kantaluokan versioon (Animal ‚Üí ‚ÄúEl√§in √§√§ntelee.‚Äù)

Virtualilla:

C++ valitsee oikean version ajonaikaisesti

eli k√§ytt√§√§ Dog-luokan callOut-metodia

Polymorfia on siis ajonaikaista ylikirjoittamista.

üî∂ 3. Mit√§ Smart Pointer tekee?
std::unique_ptr<T> on C++:n √§lyosoitin, joka:

pit√§√§ muistissa omistamansa olion osoitteen

vapauttaa muistin automaattisesti, kun se tuhoutuu

ei tarvitse delete-komentoa koskaan

on ‚Äúainut omistaja‚Äù (unique = yksin omistava)

Normaali osoitin:

sinun pit√§√§ itse poistaa (delete)

helppo tehd√§ virheit√§

Smart pointer:

h√§vitt√§√§ olion kun muuttuja menee pois n√§kyvyydest√§

üî∂ 4. Miksi destruktori pit√§√§ olla virtual?
T√§m√§ on √§√§rimm√§isen t√§rke√§ perinn√§ss√§.

Jos tuhoat Dog-olion Animal-osoittimen kautta:

ilman virtual ~Animal()
‚Üí vain Animalin destruktori kutsutaan
‚Üí Dogin destruktori ohitetaan
‚Üí mahdollista muistivuotoa

virtual ~Animal()
‚Üí C++ kutsuu ensin Dogin destruktorin
‚Üí sitten Animalin destruktorin

T√§ydellinen tuhoamisketju.

Helppo mielikuva
Kun sinulla on ‚Äúel√§inosoitin‚Äù, mutta el√§in on oikeasti koira,
C++ ei voi tiet√§√§ t√§t√§ ilman virtuaalista destruktoria.

Siksi:

virtual ~Animal()
on pakollinen aina, kun luokalla on virtuaalisia metodeja.

üî∂ 5. Milt√§ polymorfinen luonti n√§ytt√§√§ (selitys ilman koodia)
√Ñl√§ huoli, t√§m√§ ei ole koodi ‚Äî vain sanallinen kuvaus:

Luot std::unique_ptr<Animal>

sis√§√§n luodaan Dog

kutsut ->callOut()

C++ katsoo: mik√§ olio osoittimen takana oikeasti on?

Vastaa: ‚ÄúSe on Dog ‚Üí k√§yt√§n Dogin callOut-versiota‚Äù

Tulos: ‚ÄúKoira haukkuu.‚Äù

Vaikka muuttujan tyyppi on Animal.

üî∂ 6. Miksi t√§m√§ on hy√∂dyllist√§?
Voit tehd√§ vektorin:

Animal

Dog

Cat

Bird

jne‚Ä¶

Kaikki samassa listassa, koska niill√§ on yhteinen kantaluokka.

Kutsut:

animal->callOut();

ja jokainen tekee oman √§√§nens√§.

T√§t√§ on laajennettavuus.

Lis√§√§t vain uuden periv√§n luokan (Cow), et muuta vanhaa koodia.

üî∂ 7. Mit√§ haluat seuraavaksi?
Voit valita:

1Ô∏è‚É£ Haluan n√§hd√§ esimerkkikoodin polymorfiasta (unique_ptr + Animal-tyyppinen osoitin).
2Ô∏è‚É£ Haluan selityksen vtable-taulusta (mit√§ virtual oikeasti tekee konepellin alla).
3Ô∏è‚É£ Haluan tehd√§ itse polymorfisen version ja sin√§ kerrot vain virheet.
4Ô∏è‚É£ Haluan selityksen perinn√§n tuhoutumisj√§rjestyksest√§.
5Ô∏è‚É£ Jokin muu aihe t√§ss√§ kokonaisuudessa?
Valitse numero ‚Äî menn√§√§n sill√§!